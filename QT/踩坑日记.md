# Dialog踩坑：右上角x关闭事件的处理
## 背景

创建了一个dialog，其中包含两个按钮 add 和 finish。

为add clicked信号绑定了提交的相关事件（此坑无关，不再赘述）

为finish clicked 绑定了完成事件——发出dialog退出信号，交给创建这个dialog的主页面去处理。

## 代码简述

Mydialog.cpp

```cpp
// ...
connect(add, &QPushButton::clicked, this, &Mydialog::check);
connect(finish, &QPushButton::clicked, this, &Mydialog::cleanScene);

void Mydialog::check()
{
    //... 不关注这个槽函数
}

void Mydialog::cleanScene()
{
    emit closeSignals();  // 发出信号给主页面去处理
}
```

---

mainWindows.h

```cpp
// ...
unique_ptr<Mydialog> myDialog_ = make_unique<Mydialog>();  // 对话框
// ...
```

---

mainWindows.cpp

```cpp
// ...
connect(myDialog_ .get(), &Mydialog::createExitVertex, this, &mainWindows::onDealMyDialog);
connect(myDialog_ .get(), &Mydialog::closeSignals, this, &mainWindows::onCloseMyDialog);

void mainWindows::onCloseMyDialog()
{
		// ... 
    // 一系列操作 ...

    // 3. 关闭对话窗口
    myDialog_ ->close();
}
```

## 要求

 dialog 的右上角xx也执行相关的onCloseMyDialog() 操作

 ## 问题

单纯的重写reject函数后，发现对话框无法关闭

```cpp
// myDialog.cpp
// 重写这个方法，程序能够执行onCloseMyDialog(), 但是无法退出dialog
void reject() override {
	emit closeSignals();
}
```

## 原因分析

对话框关闭（或者调用close() ）的一系列操作：

1. 触发 closeEvent
2. 调用reject方法
3. 发出rejected信号
4. 对话框隐藏（不会被销毁，除非在rejected的信号的槽函数中调用deleteLater方法）

我在写退出的方法时，重写了reject方法，导致其没有发出rejected信号。

然后在onCloseMyDialog()函数中，又一次调用了close() 函数，让其执行了reject()方法。

可以看到，这里发生了相互调用，出现**死循环**的问题。

## 解决方法

为dialog的rejected信号绑定 cleanScene() 槽函数